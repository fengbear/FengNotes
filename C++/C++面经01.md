### C++基础面经

#### 1、C++声明与定义

##### 1.1、声明

声明是用来告诉编译器变量的名称和类型，而不分配内存。

```c++
extern int var; // 声明
extern int ble =10; // 定义
typedef int INT; // 声明
struct Node; // 声明
```

##### 1.2、定义

定义是为了给变量分配内存，可以为变量赋初值。

**变量/函数可以声明多次，变量/函数的定义只能一次。**

#### 2、C++内存区域

C++中的内存分区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区和代码区。

**栈：**在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但分配的内存容量有限。

**堆**：就是那些由malloc分配的内存块，一般一个malloc就要对应一个free。

**自由存储区**：如果说堆是操作系统维护的一块内存，那么自由存储区就是C++中通过new和delete动态分配和释放对象的抽象概念。需要注意的是，自由存储区和堆比较像，但不等价。

**全局/静态存储区**：全局变量和静态变量被分配到同一块内存中，**在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0。**

**常量存储区**：这是一块比较特殊的存储区，这里面存放的是常量，不允许修改。

**代码区**：存放函数体的二进制代码。

> C语言中分为堆、栈、BSS（存放未初始化全局变量与静态变量）、Data数据段（已初始化）、TEXT文本段。

#### 3、C++ 编译流程 & 动态链接 & 静态链接

![image-20220827111605818](picture/image-20220827111605818.png)

**预编译**：展开头文件、宏替换、去掉注释、条件编译，即对#ifndef #define #endif进行判断检查，也正是在这一步，#ifndef #define #endif的作用体现出来，即防止头文件被多次重复引用

**编译：**将代码转成汇编代码

**汇编：**将汇编代码转换成机器码

**链接：**链接各个可重定位文件，形成可执行文件。

**构建静态库**

![image-20220827120447161](picture/image-20220827120447161.png)

![image-20220827120505774](picture/image-20220827120505774.png)

**构建动态库**

![image-20220827120545534](picture/image-20220827120545534.png)

静态库与所有的软件一样，需要定期维护和更新 

几乎每个C程序都要使用标准I/O函数，每次都要复制到进程的代码段中，太浪费了。 

共享库 .so (linux) .dll(windows) 共享库在运行或加载时，可以被加载到任意的内存地址，还能和一个在内存中的程序链接起来，这个过程称为动态链接

![image-20220827120659307](picture/image-20220827120659307.png)

当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完成连接过程。 此时，没有任何libvector.so的代码和数据节真的被复制到可执行文件prog21中，反之，链接器复制了一些重定位和符号表信息，它们使运行时可以解析对libvector.so中代码和数据的引用。

而静态链接库则是在链接器的时候就把目标程序和库里的函数代码链接合并在了一起成为一个可执行文件。

> 静态连接库就是把 (lib) ⽂件中⽤到的函数代码直接链接进⽬标程序，程序运⾏的时候不再需要其它的库⽂件；动态链接就是把调⽤的函数所在⽂件模块（DLL）和调⽤函数在⽂件中的位置等信息链接进⽬标程序，程序运⾏的时候再从 DLL 中寻找相应函数代码，因此需要相应 DLL ⽂件的⽀持。

#### 4、为何要在头文件中声明，源文件中定义？

1、预编译指令#include的作用是将所包含的文件全文复制到#include的位置，相当于是个展开为一个文件的宏。

2、C++允许多次声明，但只允许一次实现。

如果编译时有多个.cpp文件中#include了同一个含有函数实现的.h，这时候链接器就会在多个目标文件中找到这个函数的实现，而这在C++中是不允许的，此时就会引爆LNK1169错误:找到一个或多个重定义的符号。

因此为了让函数可以在各个.cpp中共享，正确的做法就是在.h中只声明函数，并在另一个.cpp中实现这个函数。这样就不会冲突了。

但是inline函数和constexpr可以在头文件中定义呢？inline和constexpr都是编译期展开的，不会到链接器的阶段。意思是，当链接器在工作的时候，已经完全没有inline和constexpr了，前者已经展开成代码嵌入目标文件相应位置，后者已经变成常数放在了相应位置。

**而头文件中可以写类成员函数的定义是因为类成员函数如果实现在类内部会自动变成inline函数。**

**#pragma once的作用是：在同一文件中多次include同一个头文件的时候，保证该头文件内容只会被替换一次。**

#### 5、存储类说明符

存储类说明符是一个名字的[声明语法](https://zh.cppreference.com/w/cpp/language/declarations)的*声明说明符序列*的一部分。它与名字的[作用域](https://zh.cppreference.com/w/cpp/language/scope)一同控制名字的两个独立性质：它的“存储期”和它的“链接”。

存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。

##### 5.1、存储期

程序中的所有[对象](https://zh.cppreference.com/w/cpp/language/object)都具有下列存储期之一：

- **自动（automatic）**存储期。这类对象的存储在外围代码块开始时分配，并在结束时解分配。未声明为 static、extern 或 thread_local 的所有局部对象均拥有此存储期。举例：**普通局部变量。**
- **静态（static）**存储期。这类对象的存储在程序开始时分配，并在程序结束时解分配。这类对象只存在一个实例。所有在命名空间（包含全局命名空间）作用域声明的对象，加上声明带有 static 或 extern 的对象均拥有此存储期。举例：**非局部变量与静态局部变量**
- **线程（thread）**存储期。这类对象的存储在线程开始时分配，并在线程结束时解分配。每个线程拥有它自身的对象实例。只有声明为 thread_local 的对象拥有此存储期。thread_local 能与 static 或 extern 一同出现，它们用于调整链接。
- **动态（dynamic）**存储期。这类对象的存储是通过使用[动态内存分配](https://zh.cppreference.com/w/cpp/memory)函数来按请求进行分配和解分配的。关于具有此存储期的对象的初始化的细节，见 [new 表达式](https://zh.cppreference.com/w/cpp/language/new)。

##### 5.2、链接

如果某个名字具有链接，那么它所指代的实体与另一作用域中的声明所引入的相同名字指代相同的实体。如果有变量、函数或其他实体在数个作用域声明但没有足够的链接，那么就会生成该实体的多个实例。

**无链接**

**名字只能从它所在的作用域使用。** 在块作用域声明的下列任何名字均无链接：

- 未显式声明为 extern 的变量（不管有没有 static 修饰符）；
- [局部类](https://zh.cppreference.com/w/cpp/language/class#.E5.B1.80.E9.83.A8.E7.B1.BB)和它的成员函数；
- 在块作用域声明的其他名字，例如 typedef、枚举及枚举项。

**内部链接**

**名字可从当前翻译单元（当前文件）中的所有作用域使用。** 在命名空间作用域声明的下列任何名字均具有内部链接；

- **声明为 static 的变量**、变量模板 (C++14 起)、函数或函数模板；
- 未声明为 extern 且先前未声明为具有外部链接的非 volatile 非模板 (C++14 起)非 inline (C++17 起)且未被导出 (C++20 起)的 [const 限定的](https://zh.cppreference.com/w/cpp/language/cv)变量（包含 [constexpr](https://zh.cppreference.com/w/cpp/language/constexpr)） (C++11 起)；
- [匿名联合体](https://zh.cppreference.com/w/cpp/language/union)的数据成员。

**外部链接**

**名字能从其他翻译单元中的作用域使用。**

- 以上未列出的变量与函数（即未声明为 static 的函数、命名空间作用域内未声明为 static 的非 const 变量，和所有声明为 extern 的变量）；
- 枚举；
- **类以及其成员函数、静态数据成员**（不论是否 const）、嵌套类及枚举，及首次以类体内的 [friend](https://zh.cppreference.com/w/cpp/language/friend) 声明引入的函数的名字；
- 所有未列于上的模板名（即未声明为 static 的函数模板）。

##### 5.3、静态存储期变量

```c++
int global;    // 静态存储变量，外部链接
static int one_file; // 静态存储变量，内部链接

int func1(int n){
	static int count = 0;  // 静态存储变量，无链接
}
```

##### 5.4、存储期说明符

![img](picture/1659408124634-73d74373-4829-4dc0-a123-40dc0cc44f05.png)

##### 5.5、分析static

static：静态或线程存储期与内部链接

- 当用于声明对象时，指定静态存储期（除非与thread_local协同出现）

static关键字可以用于如下情况：

- 在文件范围（全局范围/命名空间范围）声明变量或者函数时，static指定变量或者函数具有**内部链接**。在声明变量时，变量具有**静态持续时间**，并且除非您指定另一个值，否则编译器会将变量初始化为0
- 当用于声明类成员变量时，它会声明一个**静态成员变量**。它有如下特性：

- - 这个成员的一个副本由类的所有实例共享。
  - 必须在文件范围内定义静态数据成员。
  - 声明为const static的整型数据成员可以有初始值设定项。

当用于声明类成员函数时，它会声明一个**静态成员函数**。它有如下特性：

- 该函数由类的所有实例共享。
- 静态成员函数不能访问实例成员，它不关联到任何对象，因为该函数没有隐式this指针。如果要访问实例成员，请使用作为实例指针或引用的参数来声明函数。
- 静态成员函数不能为**virtual、const 或 volatile**

##### 5.6、分析thread_local

- thread_local指示对象具有**线程存储期**：

- - 使用说明符声明的变量thread_local只能在创建它的线程上访问。
  - 变量在创建线程时创建，销毁线程时销毁。
  - 每个线程都有自己的副本。

- thread_local 能与 static 或 extern 结合，以分别指定内部或外部连接（但静态数据成员始终拥有外部链接）

**全局变量**

```c
//需要包含的头文件
#include <iostream>
#include <thread>
#include <mutex>
std::mutex cout_mutex;    //方便多线程打印

static thread_local int x = 1;

void thread_func(const std::string& thread_name) {
    for (int i = 0; i < 3; ++i) {
        x++;
        std::lock_guard<std::mutex> lock(cout_mutex);
        std::cout << "thread[" << thread_name << "]: x = " << x << std::endl;
    }
    return;
}

int main() {
    std::thread t1(thread_func, "t1");
    std::thread t2(thread_func, "t2");
    t1.join();
    t2.join();
    return 0;
}

/*
thread[t2]: x = 2
thread[t2]: x = 3
thread[t2]: x = 4
thread[t1]: x = 2
thread[t1]: x = 3
thread[t1]: x = 4
*/
```

**局部变量**

```c
//需要包含的头文件
#include <iostream>
#include <thread>
#include <mutex>
std::mutex cout_mutex;    //方便多线程打印

void thread_func(const std::string& thread_name) {
    for (int i = 0; i < 3; ++i) {
        thread_local int x = 1;
        x++;
        std::lock_guard<std::mutex> lock(cout_mutex);
        std::cout << "thread[" << thread_name << "]: x = " << x << std::endl;
    }
    return;
}

int main() {
    std::thread t1(thread_func, "t1");
    std::thread t2(thread_func, "t2");
    t1.join();
    t2.join();
    return 0;
}
/*
thread[t2]: x = 2
thread[t2]: x = 3
thread[t2]: x = 4
thread[t1]: x = 2
thread[t1]: x = 3
thread[t1]: x = 4
*/
```

如果不加thread_local：

```c
thread[t2]: x = 2
thread[t2]: x = 2
thread[t2]: x = 2
thread[t1]: x = 2
thread[t1]: x = 2
thread[t1]: x = 2
```

**说明：thread_local的局部变量没有因为for循环作用域而重新赋值。这是因为线程存储期的变量都是和线程绑定的，所以只有第一次声明时被赋值。可以理解为线程的static变量。不过变量的作用域依然是在本身的作用域内。比如：在for循环外使用x就会编译时错误**

```c++
void thread_func(const std::string& thread_name) {
    for (int i = 0; i < 3; ++i) {
        thread_local int x = 1;
        x++;
        std::lock_guard<std::mutex> lock(cout_mutex);
        std::cout << "thread[" << thread_name << "]: x = " << x << std::endl;
    }
    x++;    //编译会出错：error: ‘x’ was not declared in this scope
    return;
}
```

#### 6、static

static是一个存储类说明符，控制变量、函数的“存储期”和“链接”。

**被static修饰过的变量和函数都具有了静态存储期**。

+ 第一个作用：隐藏

  当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性（外部链接）。加了static前缀的全局变量和函数就具有了内部链接，仅本文件可见。

  > 如果一个名称对编译单元(.cpp)来说是局部的，在链接的时候其他的编译单元无法链接到它且不会与其它编译单元(.cpp)中的同样的名称相冲突。

+ 第二个作用：静态存储期

  加了static的变量具有了静态存储期，存储在静态数据区。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。

+ 第三个作用：默认初始化为0

  > 其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。

+ 第四个作用：C++中类成员/函数声明static

  1、函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值

  2、在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其它函数访问

  3、在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内

  4、在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝

  5、在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量

  6、static对象必须要在类外进行初始化，**static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化**

  7、**由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员**

  8、static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this->vptr->ctable->virtual function

> 类中的静态成员变量在类中仅仅是声明，没有定义，所以要在类的外面定义，**实际上是给静态成员变量分配内存**。
>
> 由于声明为static的变量只被初始化一次，因为它们在单独的静态存储中分配了空间，因此类中的静态变量**由对象共享。**对于不同的对象，不能有相同静态变量的多个副本。也是因为这个原因，静态变量不能使用构造函数初始化。

> 类的静态成员函数也不依赖于类的对象。**我们被允许使用对象和'.'来调用静态成员函数。但建议使用类名和范围解析运算符调用静态成员。**
>
> **允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数。**

> 类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问；非静态成员（变量和方法）属于类的对象，所以只有在类的对象产生（创建类的实例）时才会分配内存，然后通过类的对象（实例）去访问。
>
> 在一个类的静态成员中去访问其非静态成员之所以会出错是因为在类的非静态成员不存在的时候类的静态成员就已经存在了，访问一个内存中不存在的东西当然会出错。
>
> 况且静态成员函数没有隐含的this指针。

##### 6.1 static为何不能类内初始化？

我的理解：当多个文件都包含一个头文件，这个头文件的类可以类内初始化静态数据成员，按照static的隐藏性，每个文件都得分配一个内存给这个静态数据成员，浪费！所以在类外定义的时候，static关键字没有，就相当于定义一个普通的全局变量，整个源文件共享一个！而类内只是一个声明（所以这个定义也不能放在头文件，不然链接时报重复冲突的错误）。

> 在类内声明的`static`变量，相当于用`extern`声明的全局变量，**都仅仅是一个声明而已**，是**U**类型的符号，如果没有对应的定义，那么就无法被链接为可执行文件或者动态链接库。
>
> 而类外的`static`变量，**相当于普通的全局变量，都是真正的定义**，是**B**类型的符号，位于*BSS*代码段中，将被分配一定的内存空间。
>
> 之所以要这样设计，**是因为一个类的头文件会在编写代码时被各个模块所引用，而这些模块却要共享这同一个类内声明的静态变量，因此绝对不能为这个变量重复地分配空间**，只能仅仅给这些模块声明一个**U**符号使这些模块通过编译，然后将这个类的静态变量在类外定义一个**B**符号，并在链接时将所有同名的**U**符号替换掉。
>
> 也就是说static成员变量本意就是一个全局变量。

**static const 可以类内是因为它在编译期进行了值替换，只是一个值而已。**

#### 7、const

##### 7.1、字面值 & 常量表达式 & constexpr

**字面值**

一个形如42的值被称为字面值常量。字面值常量的形式和值决定了常量的类型。例如0x42是16进制表示的整型常量。‘a'是char型字面值。**字面值常量顾名思义由字面意思表示，是常量**。字面值常量在程序中是直接表示的，整型直接写出大小，字符直接写出字符。

**常量表达式**

常量表达式是指在编译过程中，该表达式的值不会改变，且编译过程中可以立即得到结果的表达式。一部分const对象是常量表达式，由常量表达式初始化的const对象也是常量表达式。常量表达式在程序运行时不会改变，即使一个程序多次启动或外部参数发生变化，该值也不会改变。编译器在编译时可能把常量表达式直接替换为立即数，具体要看编译环境。一般来讲，**字面值常量属于常量表达式。**

**const & constexpr**

const修饰的变量可以被常量表达式初始化（这时const变量可以用于指定数组大小），也可以被编译期不能计算出值的表达式初始化，比如大部分函数的返回值（这时const变量，不能用于指定数组大小）。

**constexpr修饰的变量，一定要用常量表达式初始化，一定是常量**（严格说，const还是不能被修改的变量，constexpr已经可以丧失变量概念了），一定可以用于指定数组的大小。

那么什么是常量？

1. 值不能被修改且 
2. 用编译期能计算出值的表达式初始化

```c++
const int a = 10;//是
const int b = a + 1;//是
int c = 10;//不是，不满足条件1
const int d = fun( void ); //不是，不满足条件2
```

**所以说大部分情况下，const只是一个只读的变量而已！！！**

##### 7.2、const对象默认为文件局部变量

注意：非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显式地指定它为extern。

> 未被const修饰的变量在不同文件的访问

```c++
// file1.cpp
int ext
// file2.cpp
#include<iostream>

extern int ext;
int main(){
    std::cout<<(ext+10)<<std::endl;
}
```

> const常量在不同文件的访问

```c++
//extern_file1.cpp
extern const int ext=12;
//extern_file2.cpp
#include<iostream>
extern const int ext;
int main(){
    std::cout<<ext<<std::endl;
}
```

> 小结：
> 可以发现未被const修饰的变量不需要extern显式声明！而const常量需要显式声明extern，并且需要做初始化！因为const变量在定义后就不能被修改，所以定义时必须初始化。

##### 7.3、指针与const

与指针相关的const有四种：

```c++
const char * a; //指向const对象的指针或者说指向常量的指针。
char const * a; //同上
char * const a; //指向类型对象的const指针。或者说常指针、const指针。
const char * const a; //指向const对象的const指针。
```

> 小结：
>
> 如果const位于`*`的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；
> 如果const位于`*`的右侧，*const*就是修饰指针本身，即指针本身是常量。

##### 7.4、函数中使用const

> const修饰函数返回值

这个跟const修饰普通变量以及指针的含义基本相同：

（1）**const int**

```c++
const int func1();
```

这个本身无意义，因为参数返回本身就是赋值给其他的变量！

（2）**const int***

```c++
const int* func2();
```

指针指向的内容不变。

（3）int *const

```c++
int *const func2();
```

指针本身不可变。

> const修饰函数参数

（1）传递过来的参数及指针本身在函数内不可变，无意义！

```c++
void func(const int var); // 传递过来的参数不可变
void func(int *const var); // 指针本身不可变
```

表明参数在函数体内不能被修改，但此处没有任何意义，var本身就是形参，在函数内不会改变。包括传入的形参是指针也是一样。**输入参数采用“值传递”，由于函数将自动产生临时变量用于复制该参数，该输入参数本来就无需保护，所以不要加const 修饰。**

（2）**参数指针所指内容为常量不可变**

```c++
void StringCopy(char *dst, const char *src);
```

其中src 是输入参数，dst 是输出参数。给src加上const修饰后，如果函数体内的语句试图改动src的内容，编译器将指出错误。这就是加了const的作用之一。、

（3）**参数为引用，为了增加效率同时防止修改。**

```c++
void func(const A &a)
```

对于非内部数据类型的参数而言，像void func(A a) 这样声明的函数注定效率比较低。因为函数体内将产生A 类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间。

为了提高效率，可以将函数声明改为void func(A &a)，因为“引用传递”仅借用一下参数的别名而已，不需要产生临 时对象。

> 但是函数void func(A &a) 存在一个缺点：
>
> “引用传递”有可能改变参数a，这是我们不期望的。解决这个问题很容易，加const修饰即可，因此函数最终成为 void func(const A &a)。

**以此类推，是否应将void func(int x) 改写为void func(const int &x)，以便提高效率？完全没有必要，因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。**

> 小结：
> 1.对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将void func(A a) 改为void func(const A &a)。
>
> 2.对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void func(int x) 不应该改为void func(const int &x)。

##### 7.5、类中使用const

在一个类中，任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改数据成员，或者调用了其它非const成员函数，编译器将指出错误，这无疑会提高程序的健壮性。

**const 成员变量**：只在某个对象⽣命周期内是常量，⽽对于整个类⽽⾔是可以改变的。因为 类可以创建多个对象，不同的对象其 const 数据成员值可以不同。所以不能在类的声明中初始化 const 数据成员， 因为类的对象在没有创建时候，编译器不知道 const 数据成员的值是什么。**const 数据成员的初始化只能在类的构造函数的初始化列表中进⾏。**

> const修饰的变量初始化后不能改变，具有只读属性，const数据成员每个对象都有一个，如果你直接const int a=b ，那么每个对象创建后都是一样的值，所以只好将其改成用初始化列表初始化了

> const 成员函数中如果实在想修改某个变量，可以使⽤ mutable 进⾏修饰。

**const对象只能访问const成员函数**，**而非const对象可以访问任意的成员函数，包括const成员函数**。

**原因**：对象调⽤成员函数时，在形参列表的最前⾯加⼀个形参 this，但这是隐式的。this 指针是默认指向调⽤函数的当前对象的，所以，很⾃然， this 是⼀个常量指针 test * const，因为不可以修改 this 指针代表的地址。但当成员函数的参数列表（即⼩括号） 后加了 const 关键字（void print() const;），此成员函数为常量成员函数，此时它的隐式this形参为 const test * const，即不可以通过 this 指针来改变指向对象的值。

##### 7.6、补充static & const

+ 我们可以在类的内部也可以在类外部定义**静态成员函数**，在外部定义时不用再写static。
+ **因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。所以它们不是由类的构造函数初始化的。**
+ **一般来说，我们不能在类的内部初始化静态数据成员。必须在类的外部定义和初始化每个静态数据成员！**

+ > 注意是静态数据成员，不是静态成员函数。

+ 类似全局变量，静态数据成员定义在任何函数之外。一旦被定义，就存在程序整个生命周期中。

+ **一般来说，静态数据成员不应该在类内部初始化。但可以为静态数据成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr**。初始值必须是常量表达式！因为这些成员本身就是常量表达式，

```c++
class Account {
public:
	static double rate() { return interestRate; }
	static void rate(double);
private:
	static constexpr int period = 30;  // 常量表达式
	double daily_tbl[period];
};
```

> 如果如上式，这个静态成员应用场景只是编译器可以替换他的值，不需要再外部定义了。
>
> 举个栗子：
>
> 如果period的唯一用途就是定义daily_tbl的维度，则不需要在Account外面专门定义period。
>
> 但如果需要把Account::period传递给一个接受const int&的函数时，必须定义period。
>
> 类内提供了初始值，再定义就不用指定初始值了，如下就可以了：
>
> `constexpr int Account::period`

+ **静态数据成员类型可以是它所属的类类型，非静态数据成员不可以！**

+ **静态数据成员还可以作为默认实参，非静态数据成员不可以**

  ```c++
  class Screen {
  public:
  	Screen &clear(char = bkground);
  private:
  	static const char bkground;
  }
  ```

  > 非静态数据成员不可以，因为它本身是对象的一部分。

#### 8、虚函数可以内联函数吗？

- 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
- **内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。**
- `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

#### 9、extern

##### 9.1、C++和C编译区别

在C++中常在头文件见到extern "C"修饰函数，那有什么作用呢？ 是用于C++链接在C语言模块中定义的函数。

C++虽然兼容C，但C++文件中函数编译后生成的符号与C语言生成的不同。因为C++支持函数重载，C++函数编译后生成的符号带有函数参数类型的信息，而C则没有。

例如`int add(int a, int b)`函数经过C++编译器生成.o文件后，`add`会变成形如`add_int_int`之类的, 而C的话则会是形如`_add`, 就是说：相同的函数，在C和C++中，编译后生成的符号不同。

这就导致一个问题：如果C++中使用C语言实现的函数，在编译链接的时候，会出错，提示找不到对应的符号。此时`extern "C"`就起作用了：告诉链接器去寻找`_add`这类的C语言符号，而不是经过C++修饰的符号。

**extern "C"的作用是，告诉C++编译器，下面的代码按照C的方式进行编译**

##### 9.2、C++调用C函数

C++调用C函数的例子: 引用C的头文件时，需要加`extern "C"`

```c++
//add.h
#ifndef ADD_H
#define ADD_H
int add(int x,int y);
#endif

//add.c
#include "add.h"

int add(int x,int y) {
    return x+y;
}

//add.cpp
#include <iostream>
#include "add.h"
using namespace std;
int main() {
    add(2,3);
    return 0;
}
```

编译：

```c++
//Generate add.o file
gcc -c add.c
```

链接：

```c++
g++ add.cpp add.o -o main
```

没有添加extern "C" 报错：

```c++
> g++ add.cpp add.o -o main                                   
add.o：在函数‘main’中：
add.cpp:(.text+0x0): `main'被多次定义
/tmp/ccH65yQF.o:add.cpp:(.text+0x0)：第一次在此定义
/tmp/ccH65yQF.o：在函数‘main’中：
add.cpp:(.text+0xf)：对‘add(int, int)’未定义的引用
add.o：在函数‘main’中：
add.cpp:(.text+0xf)：对‘add(int, int)’未定义的引用
collect2: error: ld returned 1 exit status
```

添加extern "C"后：

```c++
add.cpp
#include <iostream>
using namespace std;
extern "C" {
    #include "add.h" // 以C的方式编译 
}
int main() {
    add(2,3);
    return 0;
}
```

编译的时候一定要注意，先通过gcc生成中间文件add.o。

```c++
gcc -c add.c 
```

然后编译：

```c++
g++ add.cpp add.o -o main
```

而通常为了C代码能够通用，即既能被C调用，又能被C++调用，头文件通常会有如下写法：

```c++
#ifdef __cplusplus
extern "C"{
#endif
int add(int x,int y);
#ifdef __cplusplus
}
#endif
```

即在C++调用该接口时，会以C接口的方式调用。这种方式使得C++者不需要额外的extern C，而标准库头文件通常也是类似的做法，否则你为何不需要extern C就可以直接使用stdio.h中的C函数呢？

##### 9.3、C中调用C++函数

**`extern "C"`在C中是语法错误，需要放在C++头文件中。**

```c++
// add.h
#ifndef ADD_H
#define ADD_H
extern "C" {
    int add(int x,int y);
}
#endif

// add.cpp
#include "add.h"          // 这样add.cpp还是以c的方式编译 

int add(int x,int y) {
    return x+y;
}

// add.c
extern int add(int x,int y); // add.c 自然也能找到该函数了
int main() {
    add(2,3);
    return 0;
}
```

编译：

```
g++ -c add.cpp
```

链接：

```
gcc add.c add.o -o main
```

综上，总结出使用方法，在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern "C"声明，在.c文件中包含了extern "C"时会出现编译语法错误。**所以使用extern "C"全部都放在于cpp程序相关文件或其头文件中。**

#### 10、struct & class

##### 10.1、C中的struct

+ 在C中struct只单纯的用作数据的复合类型，也就是说，**在结构体声明中只能将数据成员放在里面**，而不能将函数放在里面。
+ 在C结构体声明中不能使用C++访问修饰符，如：public、protected、private 而在C++中可以使用。
+ 在C中定义结构体变量，如果使用了下面定义必须加struct。
+ C的结构体不能继承（没有这一概念）。
+ 若结构体的名字与函数名相同，可以正常运行且正常的调用！例如：可以定义与 struct Base 不冲突的 void Base() {}。

```c++
#include<stdio.h>

struct Base {            // public
    int v1; 
//    public:      //error
        int v2; 
    //private:
        int v3; 
    //void print(){       // c中不能在结构体中嵌入函数
    //    printf("%s\n","hello world");
    //};    //error!
};

void Base(){
    printf("%s\n","I am Base func");
}
//struct Base base1;  //ok
//Base base2; //error
int main() {
    struct Base base;
    base.v1=1;
    //base.print();
    printf("%d\n",base.v1);
    Base();
    return 0;
}
```

##### 10.2、C++中struct

与C对比如下：

- C++结构体中不仅可以定义数据，还可以定义函数。
- C++结构体中可以使用访问修饰符，如：public、protected、private 。
- C++结构体使用可以直接使用不带struct。
- C++继承
- 若结构体的名字与函数名相同，可以正常运行且正常的调用！但是定义结构体变量时候只用用带struct的！

例如：

> 情形1：不使用typedef定义结构体别名

未添加同名函数前：

```c++
struct Student {
    
};
Struct Student s; //ok
Student s;  //ok
```

添加同名函数后：

```c++
struct Student {
    
};
void Student(){}
Struct Student s; //ok
Student s;  //error
```

> 情形二：使用typedef定义结构体别名

```c++
typedef struct Base1 {         
    int v1;
    public:     //显示声明public
        int v2;
    void print(){       
        printf("%s\n","hello world");
    };    
}B;
//void B() {}  //error! 符号 "B" 已经被定义为一个 "struct Base1" 的别名
```

##### 10.3、struct & class

最本质的一个区别就是默认的访问控制

默认的继承访问权限。struct 是 public 的，class 是 private 的。

struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。

#### 11、union

联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：

- 默认访问控制符为 public
- 可以有含有构造函数、析构函数的类类型成员
- 不能含有引用类型的成员
- 不能继承自其他类，不能作为基类
- 不能含有虚函数
- 匿名 union 在定义所在作用域可直接访问 union 成员
- 匿名 union 不能包含 protected 成员或 private 成员，也不能定义成员函数
- 全局匿名联合必须是静态的，当在一个命名空间中声明匿名联合时（例如：在全局空间中），它必须被声明为static类型。也就是 `static union { };`

匿名union是一个未命名的union，并且在右花括号和分号之间没用任何声明，一旦我们定义了一个匿名union，编译器就自动地为该union创建一个未命名的对象：

```c++
union {
	char cval;
	int ival;
	double dval;
};
cval = 'c'; // 为刚刚定义的未命名的匿名union对象赋一个新值
```

匿名 union 在定义所在作用域可直接访问 union 成员。

#### 12、直接初始化与拷贝初始化

+ **当用于类类型对象时，初始化的拷贝形式和直接形式有所不同**：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。**拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。**

+ ```c++
  string str1("I am a string");//语句1 直接初始化
  string str2(str1);//语句2 直接初始化，str1是已经存在的对象，直接调用拷贝构造函数对str2进行初始化
  string str3 = "I am a string";//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3
  string str4 = str1;//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数
  // 这是虽然使用了"="，但是实际上使用对象str1来创建一个新的对象str4。也就是产生了新的对象，所以调用的是拷贝构造函数。
  // 如果对一个已存在的数使用 = 则是调用赋值运算符
  ```

+ 直接初始化是根据参数寻找最优匹配构造函数的过程，所以上面两个都是直接初始化，但是第二个调用的是拷贝构造函数初始化。

+ 拷贝初始化时，要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要还要进行类型转换。

  **拷贝初始化不仅是 = 定义变量是会发生，在下列情况也会发生**： 

  + 将一个对象作为实参传递给一个非引用类型的形参
  + 从一个返回类型是非引用类型的函数返回一个对象
  + 用花括号列表初始化一个数组中的元素或一个聚合类的成员。

#### 13、类型转换运算符

类型转换函数一般形式如下：

```c++
operator type() const;
```

type表示某种类型。类型转换运算符可以面向任意类型（除了void）进行定义，只要该类型能作为函数的返回类型。因此，我们不允许转换成数组或者函数类型，但允许转换成指针。

**类型转换运算符既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数。**

+ 例子：

  ```c++
  class SmallInt {
  public:	
      SmallInt(int i = 0) : val(i) {              
          // 转换构造函数		
          if (i < 0 || i > 255) {			
              throw std::out_of_range("Bad SmallInt value");		
          }	
      }	
      operator int() const { 
          return val; 
      }
  private:	
      size_t val;
  };
  SmallInt si;
  si = 4; // 首先将4隐式地转换成SmallInt
  si + 3; // 将si隐式转换成int，然后执行整数的加法
  ```

  我们能使用类型转换运算符将一个SmallInt对象转换成int。然后再将所得的int转换成任何其他算术类型

  ```c++
  SmallInt si;si + 3.14; // si先转换成int，int转换成double
  ```

##### 13.1、显式的类型转换运算符

```c++
class SmallInt {
public:	
    explicit operator int() const { 
        return val; 
    }
private:	
    size_t val;
};
SmallInt si;
si + 3; // 错误
static_cast<int>(si) + 3; // 正确
```

但如果表达式出现在下列位置，可以隐式执行：

+ if、while及do语句的条件部分
+ for语句头的条件表达式
+ ！|| &&的运算对象
+ 条件运算符（？ ：）的条件表达式

> **被用作条件就可以隐式**

IO标准库定义了一个向bool的显式类型转换。

```c++
while(cin >> value)
```

执行输入运算符，它负责将数据读入value，返回cin。返回的cin作为条件，可以触发显示地类型转换为bool，当cin的条件状态是good就为真。

##### 13.2、避免有二义性的类型转换

+ 两个类提供相同的类型转换：A类定义了一个接受B的类对象的构造函数，B类定义了一个转换目标是A

  ```c++
  struct B;
  struct A {	
      A() = default;	
      A(const B&);
  };
  struct B {	
      operator A() const;
  };
  A f(const A&);
  B b;
  A a = f(b); // 二义性错误， 含义是 f(B::operator A()) 还是f(A::A(const B&));
  // 显式
  A a1 = f(b.operator A());
  A a2 = f(A(b));
  ```

+ 类定义了一组类型转换，它们的转换源（或者转换目标）类型本身可以通过其他类型联系在一起，则也会产生二义性。

  ```c++
  struct A {	
      A(int = 0);                 // 转换构造	
      A(double);	
      operator int() const;	
      operator double() const;
  };
  void f2(long double);
  A a;
  f2(a);      // 二义性错误：含义是f(A::operator int()) 还是 f(A::operator double())
  long lg;
  A a2(lg); // 二义性错误：含义是A::A(int) 还是A::A(double)
  ```

##### 13.3、重载函数与转换构造函数

+ 当调用重载函数时，如果两个或多个用户定义的类型转换都提供了**可行匹配**，则我们认为这些类型转换一样好。不会考虑任何可能出现的标准类型转换的级别。

  ```c++
  struct C {	
      C(int);
  };
  struct D {	
      D(double);
  };
  void xf(C&);
  void xf(D&);
  xf(10); // 二义性 调用C(10)还是D(10)
  ```

+ 在调用重载函数时，如果需要考量哪个类型转换匹配的好，这些类型转换必须是**同一个用户（类）**定义的类型转换才行。

  ```c++
  struct A {	
      A(int = 0);                 // 转换构造	
      A(double);	
      operator int() const;	
      operator double() const;
  };
  short lg;
  A a2(lg); // 匹配A(int) 因为short转int优于转double
  ```

##### 13.4、函数匹配与重载运算符

+ 重载运算符也是重载的函数。
+ 当我们使用重载运算符作用于类类型的运算对象时，候选函数中包含该运算符的普通非成员版本和内置版本。除此之外，如果左侧运算对象是类类型，则定义在该类中的运算符的重载版本也包含在内。

```c++
class SmallInt {	
    friend SmallInt operator+(const SmallInt&, const SmallInt&);
public:	
    SmallInt(int); // 转化源为int	
    operator int() const { return val; } // 转换目标为int
private:	
    size_t val;
};
SmallInt s1,s2;
SmallInt s3 = s1 + s2; // 使用重载的operator+int i = s3 + 0;   // 二义性错误
```

#### 14、explicit

+ explicit修饰构造函数时，可以防止隐式转换和拷贝初始化。

+ explicit 修饰类型转换函数时，可以防止隐式转换，但按语境转换除外

```c++
#include <iostream>
using namespace std;
struct A
{
    A(int) { }
    operaor bool() const { return true; }
};
struct B
{
    explicit B(int) {}
    explicit operator bool() const { return true; }
};
void doA(A a) {}
void doB(B b) {}
int main() {
    // B b2 = 1;    // 错误：被 explicit 修饰构造函数的对象不可以复制初始化  
    // doB(1);      // 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换
    B b1(1);        // OK：直接初始化
    if (b1);        // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从B到bool的按语境转换 用作条件就可以隐式抓换
	// bool b2 = b1;                  // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
    bool b3 = static_cast<bool>(b1);  // OK：static_cast 进行直接初始化
}
```

+ 在构造函数前加explicit关键字可以抑制隐式转换。**只对一个实参的构造函数有效，需要多个实参的构造函数不能隐式转换，也无须将构造函数指定为explicit**
+ 隐式转换构造函数只能使用直接初始化了，因为拷贝形式的初始化也会发生隐式转换

#### 15、宏定义 & typedef  & using & 宏 & inline函数 & const

##### 15.1、宏定义

**#define**

宏定义，C语言中预处理命令一种。分为无参宏定义和带参宏定义。无参宏定义的一般形式为：#define 宏名 字符串；带参宏定义的一般形式为：#define 宏名（参数表） 字符串，被定义的字符串称为替换文本。
**不带参的**：

```c++
#define <宏名>　　<字符串>
#define A 1
```

**带参数的**：

```C++
#define <宏名> (<参数表>) <宏体>
#define A(x) x
```

编译预处理时，对程序中所有出现的“宏名”，都用宏定义中的[字符串](https://so.csdn.net/so/search?q=字符串&spm=1001.2101.3001.7020)去代换，这称为“宏代换”或“宏展开”。。宏展开是在预处理阶段完成的，这个阶段把替换文本只是看作一个字符串，并不会有任何的计算发生，在展开时在宏出现的地方只是**简单地使用字符串来代替**，并不会增添任何的符号。**这只是一种简单的代换，字符串中可以含任何字符，可以是常数，也可以是表达式，预处理程序对它不作任何检查。如有错误，只能在编译已被宏展开后的源程序时发现。**

宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起置换。

这里补充几点宏相关知识点：

宏中包含几个特殊符号：`#`，`##`，`\`

+ ```c++
  #define exp(s) printf("test s is:%s\n",s)
  #define exp1(s) printf("test s is:%s\n",#s)
  #define exp2(s) #s 
  int main() {
      exp("hello");
      exp1(hello);
      string str = exp2(bac);
      cout<<str<<" "<<str.size()<<endl;
      /**
       * 忽略传入参数名前面和后面的空格。
       */
      string str1 = exp2( asda  bac );
      /**
       * 当传入参数名间存在空格时，编译器将会自动连接各个子字符串，
       * 用每个子字符串之间以一个空格连接，忽略剩余空格。
       */
      cout<<str1<<" "<<str1.size()<<endl;
      return 0;
  }
  /*
  test s is:hello
  test s is:hello
  bac 3
  asda bac 8 
  */
  ```

+ **符号连接操作符（##）：“##”是一种分隔连接方式，它的作用是先分隔，然后进行强制连接。将宏定义的多个形参转换成一个实际参数名。**

  注意事项：

  + **当用##连接形参时，##前后的空格可有可无。**
  + **连接后的实际参数名，必须为实际存在的参数名或是编译器已知的宏定义。**
  + **如果##后的参数本身也是一个宏的话，##会阻止这个宏的展开，也就是只替换一次。**

  ```c++
  #define expA(s) printf("前缀加上后的字符串为:%s\n",gc_##s)  //gc_s必须存在
  // 注意事项2
  #define expB(s) printf("前缀加上后的字符串为:%s\n",gc_  ##  s)  //gc_s必须存在
  // 注意事项1
  #define gc_hello1 "I am gc_hello1"
  int main() {
      // 注意事项1
      const char * gc_hello = "I am gc_hello";
      expA(hello);
      expB(hello1);
  }
  /*
  前缀加上后的字符串为:I am gc_hello
  前缀加上后的字符串为:I am gc_hello1
  */
  #define STRCPY(a, b)    strcpy(a ## _p, #b)
  int main()
  {
      char var1_p[20];
      char var2_p[30];
       /* 注意这里 */
      STRCPY(STRCPY(var1,var2),var2);
      /* 这里是否会展开为： strcpy(strcpy(var1_p,"var2")_p,"var2“）？
       * 答案是否定的：
       * 展开结果将是：  strcpy(STRCPY(var1,var2)_p,"var2")
       * ## 阻止了参数的宏展开!
       * 如果宏定义里没有用到 # 和 ##, 宏将会完全展开
       */
  }  
  ```

+ #### 续行操作符（\）:**当定义的宏不能用一行表达完整时，可以用”\”表示下一行继续此宏的定义。注意 \ 前留空格。

+ **避免语义曲解**

  ```c++
  #define fun() f1();f2();
  if(a>0)
  	fun()
  // 展开后
  if(a>0)
  	f1();
  	f2();
  // 为了解决这种问题，在写代码的时候，通常可以采用`{}`块。
  #define fun() {f1();f2();}
  if(a>0)
  	fun();
  // 宏展开
  if(a>0)
  {
      f1();
      f2();
  }; // 但是会发现上述宏展开后多了一个分号，实际语法不太对。(虽然编译运行没问题，正常没分号)
  ```

##### 15.2、typedef

四种用法

+ 定义类型别名

  ```c++
  char *pa, *pb;
  //char* pa,pb;
  typedef char* pCHAR;
  pCHAR pa,pb;
  ```

+ typedef struct

  在c语言中typedef struct定义结构名，在声明时可以省略struct关键字。

  ```c++
  typedef struct B
  {
      int x;
      int y;
  }pB;
  pB b;
  ```

  而C++中无typedef时，在末尾定义的是变量，可以直接使用它对结构中的成员变量进行赋值；而有typedef 时，在末尾定义的是结构类型，相当于为struct定义的结构类型换了一个新的名字，使用时，需要先定义变量，然后对结构中的成员变量进行赋值。

  ```c++
  struct Teacher
  {   
      int age;
  }Tea;  //Tea是一个变量  
  
  typedef struct Student
  {   
      int age;
  }Stu;  //Stu是一个结构体类型 = struct Student
  
  void main()
  {
      Tea.age = 30;  //为结构成员赋值
      Stu Zhang;   //先声明结构类型变量
      Zhang.age = 15;   //访问结构成员并赋值
  }
  ```

+ 定义与平台无关的数据类型

  ```c++
  比如定义一个叫 REAL 的浮点类型，在目标平台一上，让它表示最高精度的类型为：
  
  typedef long double REAL; 
  //在不支持 long double 的平台二上，改为：
  typedef double REAL; 
  //在连 double 都不支持的平台三上，改为：
  typedef float REAL; 
  ```

  **也就是说，当跨平台时，只要改下 typedef 本身就行，不用对其他源码做任何修改。** 标准库就广泛使用了这个技巧，比如size_t。 另外，因为typedef是定义了一种类型的新别名，不是简单的字符串替换，所以它比宏来得稳健（虽然用宏有时也可以完成以上的用途）。

+ **为复杂的声明定义一个简单别名**

  ```c++
  int *(*a[5])(int, char*); //原声明
  
  typedef int *(*pFun)(int, char*);
  pFun a[5];
  ```

**如何理解复杂声明和定义**

c++创始人写的<the design and evolution of cpp>中的下面这个例子:

```c++
typedef int P();
// declares a function type P as returning an int and taking no arguments.
class X {
    static P(Q); // 等价于`static int Q()`, Q在此作用域中不再是一个类型
};
```

**任何声明变量的语句前面加上typedef之后，原来是变量的都变成一种类型**。**不管这个声明中的标识符号出现在中间还是最后**。

```cpp
typedef int P();
static P(Q); 
```

P是一个新定义的function类型, 它返回值为int, 无参数。P(Q); 实际上等价于P Q, 声明Q是一个**返回值为int, 无参数的函数**。

**右左法则**

当声明和定义逐渐复杂时，需要使用用于理解复杂定义的“ **右左法则** ”：

> 从变量名看起，先往右，再往左，碰到圆括号就调转阅读的方向；括号内分析完就跳出括号，还是先右后左的顺序。如此循环，直到分析完整个定义。

比如`int (*pfunc) (int)`，找到变量名pfunc，先往右是圆括号，调转方向，左边是一个`*`号，这说明pfunc是一个指针；然后跳出这个圆括号，先看右边，又遇到圆括号，这说明(*pfunc)是一个函数，所以pfunc是一个指向这类函数的指针，即函数指针，这类函数具有一个int类型的参数，返回值类型是int。

比如`int (*arr[10]) (int)`，先往右是[]运算符，说明arr是一个数组；再往左是一个`*`号，说明arr数组的元素是指针（**注意**：这里的*修饰的不是arr，而是arr[10]。原因是[]运算符的优先级比*要高，arr先与[]结合。）；跳出圆括号，先往右又遇到圆括号，说明arr数组的元素是指向函数的指针，它指向的函数有一个int类型的参数，返回值类型是int。

那么，怎么判断定义的是函数指针，还是数组指针，或是数组呢？可以抽象出几个模式：

```cpp
typedef (*var)(...); // 变量名var与*结合，被圆括号括起来，右边是参数列表。表明这是函数指针
typedef (*var)[];  //变量名var与*结合，被圆括号括起来，右边是[]运算符。表示这是数组指针
typedef (*var[])...;// 变量名var先与[]结合，说明这是一个数组（至于数组包含的是什么，由旁边的修饰决定）
```

下面可以利用右左法则去分析复杂的声明和定义：

```cpp
void * (* (*fp1) (int)) [10];
```

找到变量名fp1，往右看是圆括号，调转方向往左看到`*`号，说明fp1是一个指针；跳出内层圆括号，往右看是参数列表，说明fp1是一个函数指针，接着往左看是*号，说明指向的函数返回值是指针；再跳出外层圆括号，往右看是[]运算符，说明函数返回的是一个数组指针，往左看是void *，说明数组包含的类型是void *。 简言之 ，fp1是一个指向函数的指针，该函数接受一个整型参数并返回一个指向含有10个void指针数组的指针。

```cpp
typedef double (* (* (*fp3) ()) [10]) ();
fp3 a;
```

如果创建许多复杂的定义，可以使用typedef。这一条显示typedef是如何缩短复杂的定义的。

跟前面一样，先找到变量名fp3（这里fp3其实是新类型名），往右看是圆括号，调转方向往左是`*`，说明fp3是一个指针；跳出圆括号，往右看是空参数列表，说明fp3是一个函数指针，接着往左是`*`号，说明该函数的返回值是一个指针；跳出第二层圆括号，往右是[]运算符，说明函数的返回值是一个数组指针，接着往左是*号，说明数组中包含的是指针；跳出第三层圆括号，往右是参数列表，说明数组中包含的是函数指针，这些函数没有参数，返回值类型是double。简言之，fp3是一个指向函数的指针，该函数无参数，且返回一个含有10个指向函数指针的数组的指针，这些函数不接受参数且返回double值。

这二行接着说明：a是fp3类型中的一个。

```cpp
int (* (*fp4()) [10]) ();
```

这里fp4不是变量定义，而是一个函数声明。

找到变量名fp4，往右是一个无参参数列表，说明fp4是一个函数，接着往左是`*`号，说明函数返回值是一个指针；跳出里层圆括号，往右是[]运算符，说明fp4的函数返回值是一个指向数组的指针，往左是*号，说明数组中包含的元素是指针；跳出外层圆括号，往右是一个无参参数列表，说明数组中包含的元素是函数指针，这些函数没有参数，返回值的类型是int。简言之，fp4是一个返回指针的函数，该指针指向含有10个函数指针的数组，这些函数不接受参数且返回整型值。

##### 15.3、using

using的几种作用如下：

+ 引入命名空间，一般为了代码的冲突，都会用命名空间。using namespace std更加方便

+ 改变访问性

  ```c++
  class Base{
  public:
       std::size_t size() const { return n; }
  protected:
       std::size_t n;
  };
  class Derived : private Base {
  public:
       using Base::size;
  protected:
       using Base::n;
  };
  ```

  类Derived私有继承了Base，对于它来说成员变量n和成员函数size都是私有的，如果使用了using语句，可以改变他们的可访问性，如上述例子中，size可以按public的权限访问，n可以按protected的权限访问。 

+ 函数重载

  在继承过程中，派生类可以覆盖**重载函数的0个或多个实例，一旦定义了一个重载版本，那么其他的重载版本都会变为不可见。**

  如果对于基类的重载函数**，我们需要在派生类中修改一个，又要让其他的保持可见，必须要重载所有版本，这样十分的繁琐。**

  ```c++
  #include <iostream>
  using namespace std;
  class Base{
      public:
          void f(){ cout<<"f()"<<endl;
          }
          void f(int n){
              cout<<"Base::f(int)"<<endl;
          }
  };
  class Derived : private Base {
      public:
          using Base::f;
          void f(int n){
              cout<<"Derived::f(int)"<<endl;
          }
  };
  int main()
  {
      Base b;
      Derived d;
      d.f();
      d.f(1);
      return 0;
  }
  /*
  f()
  Derived::f(int)
  */
  ```

+ 指定别名

  C中常用typedef A B这样的语法，将B定义为A类型，也就是给A类型一个别名B

  对应typedef A B，使用using B=A可以进行同样的操作。

  ```c++
  typedef vector<int> V1; 
  using V2 = vector<int>;
  ```


##### 15.4、inline函数

当程序执行函数调用指令时，CPU将存储该函数调用后指令的内存地址，将函数的参数复制到堆栈上，最后将控制权转移到指定的函数。然后，CPU执行函数代码，将函数返回值存储在预定义的内存位置/寄存器中，并将控制权返回给调用函数。如果函数的执行时间少于从调用者函数到被调用函数（被调用者）的切换时间，则这可能会成为开销。对于大型函数和/或执行复杂任务的函数，与函数运行所花费的时间相比，函数调用的开销通常微不足道。但是，对于小型的常用功能，进行函数调用所需的时间通常比实际执行函数代码所需的时间多得多。对于小功能，由于小功能的执行时间少于切换时间，因此会产生开销。

C++提供了inline函数，以减少函数调用的开销。内联函数是在调用时在行中扩展的函数。调用内联函数时，将在内联函数调用时插入或替换内联函数的整个代码。替换由C++编译器在编译时执行。如果内联函数很小，则可以提高效率。

inline函数看起来像函数，动作像函数，但是又比宏方便很多，调用inline函数省去了参数压栈、生成汇编语言的 CALL调用、返回参数、执行return等过程所花费的额外开销。

不过inline函数也有缺点：增加目标码的大小。所以，inline函数对于函数体积很小，却又频繁调用这样的函数来说，可能比函数调用产生的代码更少，但是效率却不可同日而语。有一点需要注意的是：**inline只是对编译器提出一个申请，并不是强制命令。编译器可以忽略内联请求。** 

inline可以显示声明，也可以隐式声明。隐式声明方式是将函数定义在类定义之中（函数定义时没有inline关键字），编译器也会当作inline函数。另外，定义在类中的friend函数也会被隐式声明为inline函数。

**显式声明的时候必须与函数定义体放在一起才能使函数成为内联，仅将inline放在函数声明前面不起任何作用。**

此外，inline函数通常放在头文件中，因为大多数build environments在编译期进行inlining，编译器必须知道函数什么样子才能把**函数调用**替换成**函数本体**。

大多数virtual函数不能inlining：因为virtual直到**运行时**才知道调用哪个函数，而inline是在编译时进行替换。

> 补充：constexpr函数
>
> + 指能用于常量表达式的函数。函数的返回类型以及所有形参的类型都得是字面值类型（算术类型，引用，指针）。函数体必须有且只有一条return语句
>
>   ```c++
>   constexpr int new_sz() {return 42;}
>   constexpr int foo = new_sz(); // foo是一个常量表达式
>   ```
>
>   编译器把对constexpr函数的调用替换成结果值。constexpr函数被隐式地指定为内联函数。
>
> + constexpr函数不一定返回常量表达式。（也能把constexpr当普通函数用的意思！但就没有返回常量表达式那味道了。）

**内联函数和constexpr函数可以在程序中多次定义，毕竟编译器想展开函数只有函数声明不够，还需要定义。所以通常将其定义在头文件。**

##### 15.5、各类比较

###### 宏定义与函数的比较

+ 宏定义在预处理的时候完成替换，之后被替换的文本参与编译，相当于直接插入了代码，**运行时**不存在函数调用，执行起来更快，函数调用在运行时需要跳转到具体的调用函数。有函数调用的时间
+ 宏定义属于在结构体中插入代码，没有返回值；函数调用具有返回值
+ **宏定义参数没有类型，不进行类型检查，函数参数具有类型，需要检查类型**
+ 宏的参数是不占内存空间的,因为只是做字符串的替换,而函数调用时的参数传递则是具体变量之间的信息传递,形参作为函数的局部变量,显然是占用内存的.
+ 宏定义不要在最后加分号，函数是需要的

###### 宏定义与内联函数的比较

+ 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。**但是内联函数在编译时展开，而宏是由预处理器对宏进行展开**。

+ 内联函数可以进行诸如**类型安全检查、语句是否正确等编译功能**，宏不具有这样的功能；宏不是函数，而inline是函数。

+ **宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。**

  ```c++
  // 宏定义
  #define MAX(a，b) ((a)>(b)?(a):(b))
  MAX(a,"Hello")； //错误地比较int和字符串，没有参数类型检查
  // 内联函数
  #include <stdio.h>
  inline int add(int a, int b)
  {
      return (a + b);
  }
  int main(void)
  {
      int a;
      a = add(1, 2);
      printf("a+b=%d\n", a);
      return 0;
  }
  /*
  以上a = add(1, 2);处在编译时将被展开为：
  a = (a + b);
  */
  ```

+ 宏函数的一个优点是无类型，可用于任意类型。

+ 一般建议用内联函数替换宏定义。

###### 宏定义与typedef的比较

+ 作用域问题：typedef如果放在所有函数之外，它的作用域就是从它定义开始直到文件尾，如果放在某个函数内，定义域就是从定义开始直到该函数结尾。#define不管是在某个函数内，还是在所有函数之外，作用域都是从定义开始直到整个文件结尾。
+ 宏主要用于定义常量以及书写复杂的内容，typedef主要用于定义类型别名
+ 宏替换发生在预处理阶段，属于文本插入替换；typedef是编译的一部分。
+ 宏不检查类型，typedef会检查数据类型。
+ `typedef char* String_t` 定义了一个新的类型别名，有类型检查。
  `#define String_d char *` 只做了简单的替换，无类型检查。
  + 前者在**编译**的时候处理，后者在**预编译**的时候处理。
  + **同时定义多个变量的时候有区别**，主要区别在于这种使用方式：
    `String_t a,b;` `String_d c,d;`
    a，b，c 都是`char *`类型，而d为`char`类型

###### 宏定义与const的比较

- const 常量限定符，声明的常量只读，不允许修改
- 在 C++ (不是 C) 中可以用 const 值声明数组长度
- 对于全局 const 值，C++ 中默认是内部链接(跟 static 一样只允许在本文件内可见)，而不是 C 中的默认外部链接，若想在其他文件中使用必须在其他文件中重新定义或将 const 值放在头文件中(默认是外部链接放在头文件中编译可能会出现错误，默认是内部链接就不会出错)

**C++ 中推荐使用 const 代替 #define 声明常量**

```c++
#define N 12
const int N = 12；
```

+ 宏定义是字符替换，没有数据类型的区别，同时这种替换没有类型安全检查，const常量是常量的声明，有类型区别，需要在编译阶段进行类型检查
+ 宏定义是在预处理阶段展开，不能对宏定义进行调试。
+ 宏定义是直接替换，不会分配内存，const定义的变量只是值不能改变，但要分配内存空间。
+ **const 能够用于更复杂的数据类型(如：数组，结构体和类)**
+ **const 能够明确指定常量类型**
+ **const 标识符遵循变量的作用域规则，可以创建作用域为全局(仅在本文件中使用)、命名空间、函数或数据块的常量**

###### typedef与using的区别

```c++
typedef void (*FP) (int, const std::string&);
using FP = void (*) (int, const std::string&);
```

都用作给类型起别名的时候，很明显，using更加清晰明了。

using还可以给模板起别名。

```c++
template <typename T>
using Vec = MyVector<T, MyAlloc<T>>;

// usage
Vec<int> vec;
```

typedef不可以，只能包装一下再使用。

```c++
template <typename T>
using Vec = MyVector<T, MyAlloc<T>>;

// usage
Vec<int> vec;
```

**麻烦！！！**

#### 16、decltype

##### 16.1、基本使用

decltype的语法是:

```c++
decltype (expression)
```

这里的括号是必不可少的，decltype的作用是“查询表达式的类型“，因此，上面语句的效果是，返回 expression 表达式的类型。注意，decltype 仅仅“查询”表达式的类型，并不会对表达式进行“求值”。

**推导出表达式类型**

```c++
int i = 4;
decltype(i) a; //推导结果为int。a的类型为int。
```

**与using/typedef合用，用于定义类型**

```c++
using size_t = decltype(sizeof(0));//sizeof(0)的返回值为size_t类型
using ptrdiff_t = decltype((int*)0 - (int*)0);
using nullptr_t = decltype(nullptr);
vector<int >vec;
typedef decltype(vec.begin()) vectype;
for (vectype i = vec.begin; i != vec.end(); i++)
{
//...
}
```

**重用匿名类型**

在C++中，我们有时候会遇上一些匿名类型，如:

```c++
struct 
{
    int d ;
    double b;
}anon_s;
```

而借助decltype，我们可以重新使用这个匿名的结构体：

```c++
decltype(anon_s) as ;//定义了一个上面匿名的结构体
```

**泛型编程中结合auto，用于追踪函数的返回值类型**

这也是decltype最大的用途了。

```c++
template <typename T>
auto multiply(T x, T y)->decltype(x*y)
{
	return x*y;
}
```

##### 16.2、判别规则

对于decltype(e)而言，其判别结果受以下条件的影响：

如果e是一个没有带括号的标记符表达式或者类成员访问表达式，那么的decltype（e）就是e所命名的实体的类型。此外，如果e是一个被重载的函数，则会导致编译错误。 

否则 ，假设e的类型是T，如果e是一个将亡值，那么decltype（e）为T&& 

否则，假设e的类型是T，如果e是一个左值，那么decltype（e）为T&。 

否则，假设e的类型是T，则decltype（e）为T。

标记符指的是除去关键字、字面量等编译器需要使用的标记之外的程序员自己定义的标记，而**单个标记符对应的表达式**即为标记符表达式。例如：

```c++
int arr[4]
```

则arr为一个标记符表达式，而arr[3]+0不是。

```c++
int i = 4;
int arr[5] = { 0 };
int *ptr = arr;
struct S{ double d; }s ;
void Overloaded(int);
void Overloaded(char);//重载的函数
int && RvalRef();
const bool Func(int);

//规则一：推导为其类型
decltype (arr) var1; //int 标记符表达式
decltype (ptr) var2;//int *  标记符表达式
decltype(s.d) var3;//doubel 成员访问表达式
//decltype(Overloaded) var4;//重载函数。编译错误。

//规则二：将亡值。推导为类型的右值引用。

decltype (RvalRef()) var5 = 1;

//规则三：左值，推导为类型的引用。
decltype ((i))var6 = i;     //int&
decltype (true ? i : i) var7 = i; //int&  条件表达式返回左值。
decltype (++i) var8 = i; //int&  ++i返回i的左值。
decltype(arr[5]) var9 = i;//int&. []操作返回左值
decltype(*ptr)var10 = i;//int& *操作返回左值
decltype("hello")var11 = "hello"; //const char(&)[9]  字符串字面常量为左值，且为const左值。

//规则四：以上都不是，则推导为本类型

decltype(1) var12;//const int
decltype(Func(1)) var13=true;//const bool
decltype(i++) var14 = i;//int i++返回右值
```

#### 17、enum

枚举类型使我们可以将一组**整型常量**组织在一起。和类一样，**每个枚举类型定义了一种新的类型，枚举属于字面值常量类型。**

C++包含了两种枚举：限定作用域的和不限定作用域的。C++11新标准引入了限定作用域的枚举类型。定义限定作用域的枚举类型的一般形式是：首先是关键字enum class，随后是枚举类型名字以及用花括号括起来的以逗号分隔的枚举成员列表，最后是一个分号。

```c++
enum class open_modes {input, output, append};
```

定义一个名为open_modes的枚举类型，它包含三个枚举成员：input、output和append。

定义**不限定作用域的枚举类型时省略掉关键字class**，枚举类型的名字是可选的：

```c++
enum color {red, yellow, green}; 
```

```c++
enum {floatPrec = 6, doublePrec = 10, double_doublePrec = 10}; // 未命名的、不限定作用域的枚举类型
```

如果enum未命名，我们只能在定义该enum时定义它的对象。和类的定义类似，我们需要在enum定义的右侧花括号和最后的分号之间提供逗号分隔的声明列表。

```c++
enum {x=0,c=1} xf;
```

##### 17.1、枚举成员

在限定作用域的枚举类中，枚举成员的名字遵循常规的作用域准则，并且在枚举类型的作用域外是不可访问的。

与之相反，在不限定作用域的枚举类型中，枚举成员的作用域与枚举类型本身的作用域相同。

```c++
enum color {red, yellow, green}; // 不限定作用于的枚举类型
enum stoplight {red, yellow, green}; // 错误：重复定义了枚举成员
enum class peppers {res, yellow, green}; // 正确：枚举成员被隐藏了
color eyes = green; // 正确，不限定作用域的枚举类型的枚举成员位于有效的作用域中
peppers p = green; // 错误: peppers的枚举成员不在有效的作用域
color hair = color::red; // 正确，允许显式访问枚举成员
peppers p2 = peppers::red; // 正确
```

默认情况，枚举值从0开始，依次加1。不过我们也可以为一个或几个枚举成员指定专门的值：

```c++
enum class intTypes {
	charTyp = 8, shortType = 16, intTyp = 16, longTyp = 32, long_longTyp = 64
};
```

枚举值不一定唯一。

**枚举成员是const的，因此在初始化枚举成员时提供的初始值必须是常量表达式。也就是说，每个枚举成员本身就是一个常量表达式。可以在任何需要常量表达式的地方使用枚举成员。**

##### 17.2、和类一样，枚举也定义新的类型

 只要enum有名字，我们就能定义并初始化该类型的成员。要想初始化enum对象或者为enum对象赋值，必须使用该类型的一个枚举成员或者该类型的另一个对象：

```c++
open_modes om = 2;   // 错误: 2不属于类型open_modes
om = open_modes::input // 正确
```

**一个不限定作用域的枚举类型的对象或枚举成员自动地转换成整型**。因此，我们可以在任何需要整型值的地方使用它们：

```c++
int i = color::red;
int j = peppers::red;
```

##### 17.3、指定enum的大小

尽管每个enum都定义了唯一的类型，但实际上enum是由某种整型类型表示的。在C++11新标准中，我们可以在enum的名字后加上冒号以及我们想在该enum中使用的类型：

```c++
enum intValues : unsigned long long {
	charTyp = 255, shortTyp = 65535, intTyp = 65535, longTyp = 4294967295UL,
	long_longTyp = 18446744073709551615ULL
};
```

如果我们没指定enum的潜在类型，则**默认情况下限定作用域的enum成员类型是int**。**对于不限定作用域的枚举类型来说，其枚举成员不存在默认类型，我们只知道成员的潜在类型足够大，肯定能容纳枚举值**

##### 17.4、枚举类型的前置声明

在C++11新标准中，我们可以提前声明enum。**enum的前置声明必须指定其成员的大小**：

```c++
enum intValues : unsigned long long; // 不限定作用域的，必须指定成员类型
enum class open_mode; // 限定作用域的枚举类型可以使用默认成员类型int
```

和其他声明语句一样，enum的声明和定义必须匹配，这意味着该enum的所有声明和定义中成员的大小必须一致。而且，**我们不能在同一个上下文中先声明一个不限定作用域的enum名字，然后再声明一个同名的限定作用域的enum**：

```c++
enum class intValues;
enum intValues; // 错误，intValues已经被声明为限定作用域的enum
enum intValues : long; // 错误：intValues已经被声明成int
```

##### 17.5、形参匹配与枚举类型

要想初始化一个enum对象，必须使用该enum类型的另一个对象或者它的一个枚举成员。

因此，即使某个整型值恰好与枚举成员的值相等，它也不能作为函数的enum实参使用：

```c++
// 不限定作用域的枚举类型， 潜在类型因机器而异
enum Tokens {INLINE = 128, VIRTUAL = 129};
void ff(Tokens);
void ff(int);
int main()
{
	Tokens curTok = INLINE;
	ff(128); // 匹配ff(int)
	ff(curTok); // 匹配ff(Tokens)
	ff(INLINE); // 匹配ff(Tokens)
	return 0;
}
```

尽管我们不能直接将整型值传给enum形参，但是可以将一个不限定作用域的枚举类型的对象或枚举成员传给整型形参。此时，enum的值提升为int或更大的整型，实际提升结果由枚举类型的潜在类型决定。

#### 18、前置声明简单介绍

通常来说，你都不需要主动去写class A这种前置声明。**应该仅当出现了头文件循环依赖导致编译失败的时候，才去考虑去写前置声明！**

头文件循环依赖，就是说两个头文件互相include了对方，这样编译会出问题。举个例子。

有a.h(里面用了类型B的指针，所以include了b.h）：

```cpp
#pragma once

#include "b.h"
class A {
public:
    A():_b(nullptr) {}
    ~A() {}

    void set_b(B* b) {
        _b = b;
    }
    B* get_b() {
        return _b;
    }

private:
    B* _b;
};
```

有b.h:

```cpp
#pragma once
#include "a.h"

class B {
public:
    B(int i):_i(i) {}
    ~B() {}

    int i() {
        return _i;
    }

    void foo(A& a) {
        B* b = a.get_b();
        b->_i += _i;
    }

private:
    int _i;
};
```

有main.cpp （包含main函数）

```cpp
#include "a.h"
#include "b.h"
#include <iostream>
using namespace std;

int main() {
    A a;
    B b(3);
    a.set_b(&b);

    B b2(7);
    b2.foo(a);

    cout << a.get_b()->i() << endl;
    return 0;
}
```

编译main.cpp失败，报错：

```text
./b.h:13:14: error: unknown type name 'A'
 void foo(A& a) {
 ^
1 error generated.
```

修改方法，**因为a.h中只出现了类型B的指针，而未调用其成员函数或成员变量**，故可以修改a.h删除include "b.h"，增加类型B的前置声明。

```cpp
#pragma once

class B; // 前置声明！
class A {
public:
    A():_b(nullptr) {}
    ~A() {}

    void set_b(B* b) {
        _b = b;
    }
    B* get_b() {
        return _b;
    }

private:
    B* _b;

};
```

编译main.cpp通过。

当前前置声明也不是万能的解药，请注意前面的加粗黑字：

> 因为a.h中只出现了类型B的指针，而未调用其成员函数或成员变量，故……

换言之，如果a.h中使用了类型B的成员函数，则无法通过更改为前置声明的方式，来让编译通过。

比如：

```cpp
#pragma once
#include <iostream>
class B;
class A {
public:
    A():_b(nullptr) {}
    ~A() {}

    void set_b(B* b) {
        std::cout<< b->i() << std::endl; // !使用了B的成员函数
        _b = b;
    }
    B* get_b() {
        return _b;
    }

private:
    B* _b;

};
```

编译报错：

```text
./a.h:10:22: error: member access into incomplete type 'B'
        std::cout<< b->i() << std::endl;
                     ^
./a.h:3:7: note: forward declaration of 'B'
class B;
```

**这时候只能老老实实地改代码，重新梳理并设计类A和类B的关系！**

看起来有点乱，记不住？其实不难理解，因为对C++而言，不管是什么指针，它的大小都是确定的。所以只要a.h中只是出现B的指针（或引用）而没有调用其具体的成员函数，C++[编译器](https://www.zhihu.com/search?q=编译器&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A"1760926865"})是可以不去在此时理解B的具体定义的（故只添加class B的声明即可），一旦a.h中用到了B的成员，则不然，此时就需要知道B的大小了，不然如果你#include a.h，定义A的对象，如何分配内存，B的大小根本不知道！必须#include b.h！。

#### 19、friend

友元提供了一种普通函数或者类成员函数访问另一个类中的私有或保护成员的机制。也就是说有两种形式的友元：

+ 友元函数：普通函数访问某个类中的私有或保护成员。
+ 友元类：类A中的成员函数访问类B中的私有或保护成员

优点：提高了程序的运行效率。

缺点：破坏了类的封装性和数据的透明性。

总结：

- 能访问私有成员
- 破坏封装性
- 友元关系不可传递
- 友元关系的单向性
- 友元声明的形式及数量不受限制

##### 19.1、友元函数

在类声明的任何区域中声明，而定义则在类的外部。

注意，友元函数只是一个普通函数，并不是该类的类成员函数，它可以在任何地方调用，友元函数中通过对象名来访问该类的私有或保护成员。

```c++
#include <iostream>
using namespace std;
class A
{
public:
    A(int _a):a(_a){};
    friend int geta(A &ca);  ///< 友元函数
private:
    int a;
};
int geta(A &ca) 
{
    return ca.a;
}
int main()
{
    A a(3);    
    cout<<geta(a)<<endl;

    return 0;
}
```

##### 19.2、友元类

友元类的声明在该类的声明中，而实现在该类外。

```c++
friend class <友元类名>;
```

类B是类A的友元，那么类B可以直接访问A的私有成员。

```c++
#include <iostream>
using namespace std;
class A
{
public:
    A(int _a):a(_a){};
    friend class B;
private:
    int a;
};
class B
{
public:
    int getb(A ca) {
        return  ca.a; 
    };
};
int main() 
{
    A a(3);
    B b;
    cout<<b.getb(a)<<endl;
    return 0;
}
```

##### 19.3、注意

- 友元关系没有继承性 假如类B是类A的友元，类C继承于类A，那么友元类B是没办法直接访问类C的私有或保护成员。
- 友元关系没有传递性 假如类B是类A的友元，类C是类B的友元，那么友元类C是没办法直接访问类A的私有或保护成员，也就是不存在“友元的友元”这种关系。

+ 类除了把非成员普通函数定义成友元，还可以把其他类、其他类的成员函数定义为友元

+ 一个类指定了友元类，友元类的成员函数都可以访问此类的所有成员。

+ 友元在类里面声明过、**定义过**了，也需要在外面声明使得可见。

  ```c++
  struct X {
  	friend void f() {/*友元函数可以定义在类的内部*/}
  	X() {f();}
  	void g();
  	void h();
  };
  void X::g() { return f(); } // 错误：f还没声明
  void f();  
  void X::h() { return f(); } // 正确
  ```

#### 20、C实现C++多态

##### 20.1、C++实现案例

C++中的多态：在C++中会维护一张虚函数表，根据赋值兼容规则，我们知道父类的指针或者引用是可以指向子类对象的。

如果一个父类的指针或者引用调用父类的虚函数则该父类的指针会在自己的虚函数表中查找自己的函数地址，如果该父类对象的指针或者引用指向的是子类的对象，而且该子类已经重写了父类的虚函数，则该指针会调用子类的已经重写的虚函数。

```c++
#include <iostream>
using namespace std;
class A
{
    public:
        virtual void f()//虚函数实现
        {
            cout << "Base A::f() " << endl;
        }
};
class B:public A    // 必须为共有继承，否则后面调用不到，class默认为私有继承！
{
    public:
        virtual void f()//虚函数实现,子类中virtual关键字可以没有
        {
            cout << "Derived B::f() " << endl;
        }
};
int main() 
{
    A a;//基类对象
    B b;//派生类对象
    A* pa = &a;//父类指针指向父类对象
    pa->f();//调用父类的函数
    pa = &b; //父类指针指向子类对象，多态实现
    pa->f();//调用派生类同名函数
    return 0;
}
```

##### 20.2、C实现

**封装**：C语言中是没有class类这个概念的，但是有struct结构体，我们可以考虑使用struct来模拟，使用函数指针把属性与方法封装到结构体中。

**继承：**结构体嵌套

**多态：**类与子类方法的函数指针不同

在C语言的结构体内部是没有成员函数的，如果实现这个父结构体和子结构体共有的函数呢？我们可以考虑使用函数指针来模拟。但是这样处理存在一个缺陷就是：父子各自的函数指针之间指向的不是类似C++中维护的虚函数表而是一块物理内存，如果模拟的函数过多的话就会不容易维护了。

模拟多态，必须保持函数指针变量对齐(在内容上完全一致，而且变量对齐上也完全一致)。否则父类指针指向子类对象，运行崩溃！

```c++
#include <stdio.h>
/// 重定义一个函数指针类型
typedef void (*pf) ();

/**
 * @brief 父类 
 */ 
typedef struct _A
{
    pf _f;
}A;


/**
 * @brief 子类
 */
typedef struct _B
{ 
    A _b; ///< 在子类中定义一个基类的对象即可实现对父类的继承。 
}B;

void FunA() 
{
    printf("%s\n","Base A::fun()");
}
void FunB() 
{
    printf("%s\n","Derived B::fun()");
}
int main() 
{
    A a;
    B b;
    a._f = FunA;
    b._b._f = FunB;
    A *pa = &a;
    pa->_f();
    pa = (A *)&b;   /// 让父类指针指向子类的对象,由于类型不匹配所以要进行强转 
    pa->_f();
    return 0;
}
```

#### 21、空类大小多少？

1、C++空类的大小不为0，不同编译器设置不一样，vs设置为1；

2、C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；

3、带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；

4、C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址。

5、要确保两个不一样的对象拥有不同的地址，就用那1byte来在内存中占用不同地址了！

#### 22、请说一下几种情况下，下面几个类的大小各是多少？

```c++
class A {};
int main(){
  cout<<sizeof(A)<<endl;// 输出 1;
  A a; 
  cout<<sizeof(a)<<endl;// 输出 1;
  return 0;
}
```

空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。

**当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。**

```c++
class A { 
    virtual Fun(){} 
};
int main(){
  cout<<sizeof(A)<<endl;// 输出 4(32位机器)/8(64位机器);
  A a; 
  cout<<sizeof(a)<<endl;// 输出 4(32位机器)/8(64位机器);
  return 0;
}
```

因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节

```c++
class A { 
    static int a; 
};
int main(){
  cout<<sizeof(A)<<endl;// 输出 1;
  A a; 
  cout<<sizeof(a)<<endl;// 输出 1;
  return 0;
}
```

静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小

#### 23、类的对象存储空间

+ 非静态成员的数据类型大小之和
+ 编译器加入的额外成员变量（如指向虚函数表的指针）
+ 为了边缘对齐优化加入的padding

空类（无非静态数据成员）的对象的size为1，当作为基类时，size为0

#### 24、类对象的大小受哪些因素的影响？

+ 类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；
+ 内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；
+ 虚函数的话，会在类对象插入vptr指针，加上指针大小；
+ 当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展。

#### 25、C++中类的数据成员和成员函数分布情况

类分为成员变量和成员函数，我们先来讨论成员变量。

**一个类对象的地址就是类所包含的这一片内存空间的首地址**，这个首地址也就对应具体某一个成员变量的地址。（在定义类对象的同时这些成员变量也就被定义了），举个例子：

```c++
#include <iostream>
using namespace std;

class Person
{
public:
    Person()
    {
        this->age = 23;
    }
    void printAge()
    {
        cout << this->age <<endl;
    }
    ~Person(){}
public:
    int age;
};

int main()
{
    Person p;
    cout << "对象地址："<< &p <<endl;
    cout << "age地址："<< &(p.age) <<endl;
    cout << "对象大小："<< sizeof(p) <<endl;
    cout << "age大小："<< sizeof(p.age) <<endl;
    return 0;
}
//输出结果
//对象地址：0x7fffec0f15a8
//age地址：0x7fffec0f15a8
//对象大小：4
//age大小：4
```

从代码运行结果来看，对象的大小和对象中数据成员的大小是一致的，也就是说，成员函数不占用对象的内存。**这是因为所有的函数都是存放在代码区的，不管是全局函数，还是成员函数。**

要是成员函数占用类的对象空间，那么将是多么可怕的事情：定义一次类对象就有成员函数占用一段空间。

我们再来补充一下静态成员函数的存放问题：**静态成员函数与一般成员函数的唯一区别就是没有this指针**，因此不能访问非静态数据成员。

就像我前面提到的，**所有函数都存放在代码区，静态函数也不例外。所有有人一看到 static 这个单词就主观的认为是存放在全局数据区，那是不对的。**

#### 26、关于this指针你知道多少？

+ this指针是类的指针，指向对象的首地址
+ this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能使用this。
+ this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。

**this指针的用处**

一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候（全局函数、静态函数中不能使用this指针），编译器会自动将对象本身的地址作为一个隐含参数传递给函数，也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。

**类的this指针有以下特点**

(1）**this**只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，**传入参数为当前对象地址，成员函数第一个参数为**为`T * const this`

如：

```C++
class A{
public:    
    int func(int p){}
};
```

其中，**func**的原型在编译器看来应该是：

**`int func(A * const this,int p);`**

（2）由此可见，**this**在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：

```c++
A a;
a.func(10);//此处，编译器将会编译成：A::func(&a,10);
```

看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化，因此，this指针的传递效率比较高。

**this指针的存放**

this指针会因编译器不同而有不同的放置位置。**可能是栈，也可能是寄存器，甚至全局变量。**

#### 27、内存泄漏

**1) 内存泄漏**

一般我们常说的内存泄漏是指**堆内存的泄漏**。堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。应用程序般使用malloc,、realloc、 new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，**否则，这块内存就不能被再次使用，我们就说这块内存泄漏了**。

**2) 解决方法**

- 智能指针管理
- 一定要将基类的析构函数声明为**虚函数**
- 对象数组的释放一定要用**delete []**
- 有new就有delete，有malloc就有free，保证它们一定成对出现

#### 28、在类的析构函数中调用delete this，会发生什么

会导致堆栈溢出。

原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。

#### 29、在成员函数中调用delete this会出现什么问题？对象还可以使用吗？ 

在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。

当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，**只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。**

#### 30、为什么是不可预期的问题

delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。



### C++新特性





